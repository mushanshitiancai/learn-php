# 那些年，被PHP坑过的代码
作为世界上最好的语言，没有坑怎么能体现出新手与老鸟的区别呢？

## PHP的`==`暗藏杀机
先看一个比较普及的代码：

```
$a = 0;
$b = 'a';

var_dump($a == $b);  // bool(true)
```

为什么两者是相等的呢？？？？

因为PHP的`==`在比较前会尝试数据类型转换，如果有两边有数字，会转换成数字比较，于是数字字符串就被转换成了数字，而非数字字符串就会被转换成`0`，于是就相等了。

这种相等是非常危险的，在代码中非常难以发现。

再看一个例子：

```
$a = '111111111111111111111111111111110';
$b = '111111111111111111111111111111111';

var_dump($a == $b);
```

这个的比较结果是相等还是不相等呢？什么，这还要问等不等？明显不等啊。

但是，在php中，这个要看心情。。。

PHP5.3中，他们相等。PHP5.5中，他们不相等。

同样比较前，PHP会进行数据类型转换，把两者转换成整数，因为数字超过整数最大值，被截取，所以两者就一样了。

那PHP5.5为什么由作出了正确的判断呢？

再看对比：

```
$a = '111111111111111111111111111111110';
$b = '111111111111111111111111111111111';

var_dump($a == $b);  // php5.3 true  php5.5 false

$a = 111111111111111111111111111111110;
$b = 111111111111111111111111111111111;

var_dump($a == $b); // php5.3 true  php5.5 true
```

可以看到，PHP5.5中，对于这两个数字的比较，依然认为是相等的，但是对于字符串，则认为是不等的。所以可以推测：PHP5.5对于字符串数字比较做出了改进，如果转换成数字需要进行截取，则按照字符串比较。（求各位验证）

**总结:**能用`===`就不要用`==`！

## foreach中使用引用导致数据异常
代码如下：

```
$arr = array(1,2,3);
$arr2 = array('a','b','c');

foreach($arr as &$v){
}
foreach($arr2 as $v){
}

var_dump($arr);
var_dump($arr2);
```

最后的输出是多少呢？直觉上来看，两个循环对于数组都没有进行任何修改，两个数组应该没有任何变化才对。如果你这么想，那就太小看`&`的威力了。

真实的结果如下：

```
array(3) {
  [0]=>
  int(1)
  [1]=>
  int(2)
  [2]=>
  &string(1) "c"
}
array(3) {
  [0]=>
  string(1) "a"
  [1]=>
  string(1) "b"
  [2]=>
  string(1) "c"
}
```

我们惊讶的发现，第一个数组的最后一个元素被修改了。这是为什么？

首先要说明一下，PHP中循环变量在循环结束后会依然存在的：

```
var_dump($i);   // NULL
for ($i=0; $i < 3; $i++) { 
}
var_dump($i);   // int(3)
```

所以上面的例子中：

```
foreach($arr as &$v){
}
foreach($arr2 as $v){
}
```

第一个循环结束后，$v依然存在，依然保持着对$arr[2]的引用。这时对于$v的所有赋值，都会修改$arr[2]，因为他俩是引用关系嘛。

于是，第二个循环中，foreach每次都向$v赋值，赋值为$arr2的每个元素。最后第二个循环结束时，赋予$v的是$arr[2]，也就是`'c'`。

所以，如果你在循环中用了引用，循环结束后，务必记得`unset`这个循环变量。






